# Copyright 2018-2024
# Institute of Neuroscience and Medicine (INM-1), Forschungszentrum JÃ¼lich GmbH

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from typing import (
    List,
    Dict,
    Type,
    Any,
    TYPE_CHECKING,
    Union,
)
import json
import inspect

if TYPE_CHECKING:
    from ..attributes.datarecipes.base import DataRecipe

try:
    from typing import get_origin
except ImportError:
    from typing_extensions import get_origin

from ..commons.logger import logger


def get_parameters(op: Dict, detail=False):
    """
    Provided with a operation specification, return a tuple containing

    - list of parameters (List[str]) in which the specification can be updated with
    - Class of the data operation handling this operation
    """
    Runner = DataOp.get_runner_cls(op)
    return Runner.get_parameters(op, detail=detail)


def update_parameters(op: Dict, **kwargs):
    """
    Provided with a operation specification, return a shallow copy of the operation specification updated by kwargs.
    """
    Runner = DataOp.get_runner_cls(op)
    return Runner.update_parameters(op, **kwargs)


def describe_operations(ops: List[Dict], detail=False):
    """
    Provided with a list of operation specifications (List[Dict]), returns human readable description (str) of how the list of
    specification will be translated to data.
    """
    descs = []
    for idx, step in enumerate(ops, start=1):
        runner = DataOp.get_runner(step)
        descs.append(
            f"{idx} - {runner.desc(**step, detail=detail) if callable(runner.desc) else runner.desc}"
        )
    return "\n".join(descs)


class DataOp:
    """
    Base Data Operation class.

    Derived class must override the following:

    - type (class attribute): explicitly set to None in the case of AbstractDataOp

    Derived class should override the following:

    - run (instance method)
        - should accept input as the first positional argument
        - must expect arguments to be passed as kwargs
        - should gracefully handle None to be passed as arguments (noop)
        - must allow **kwargs wildcard keyword arguments
        - If not overriden, considered as noop
    - generate_specs (class method)
        - must allow keyword arguments
        - must avoid "input" as argument key
        - must avoid "force" as argument key
    - input (class attribute, Type)
        - type of input to be passed run(instance method) as the first positional argument
        - If None, considered source DataOp
        - Used to validate DataOp steps (NYI)
    - output (class attribute, Type)
        - type of output to be returned from run(instance method)
        - Used to validate DataOp steps (NYI)
    - desc (class attribute, str|Callable)
        - human readable description of what this step does. If is of type Callable, the callable should
          expect keyword arguments matching those generated by its generate_spec
    - force (class attribute, bool)
        - set to True to disable caching

    Derived class should not override anyother attributes/methods/class methods.
    """

    input: None
    output: None
    desc: str = "Noop"
    type: str = "baseop/noop"
    force = False

    step_register: Dict[str, Type["DataOp"]] = {}

    def run(self, input, **kwargs):
        return input

    def __init_subclass__(cls) -> None:
        super().__init_subclass__()
        if not cls.type:
            logger.debug(
                f"{cls.__name__} does not have type defined. Cannot register it."
            )
            return
        if cls.desc == DataOp.desc:
            logger.warning(
                f"DataOp {cls} does not have unique description for its step."
            )

        assert cls.type not in cls.step_register, f"Already registered {cls.type}"
        cls.step_register[cls.type] = cls

    @classmethod
    def get_runner_cls(cls, step: Dict):
        _type = step.get("type")
        if _type not in cls.step_register:
            logger.warning(f"{_type} not found in register. Noop rather than hard fail")
            return DataOp
        return cls.step_register[_type]

    @classmethod
    def get_runner(cls, step: Dict):
        return cls.get_runner_cls(step)()

    @classmethod
    def generate_specs(cls, force=False, **kwargs):
        return {"type": cls.type, "force": force or cls.force}

    @staticmethod
    def get_types(cls: Type, key: str):
        # This is necessary, as some type are stored on superclass
        for k in cls.__mro__:
            try:
                t = k.__annotations__[key]
                if get_origin(t) is not Union:
                    return [t]
                return [t]
            except KeyError:
                continue
        return []

    @classmethod
    def get_output_type(cls, step: Dict):
        Cls = cls.get_runner_cls(step)
        return cls.get_types(Cls, "output")

    @classmethod
    def get_input_type(cls, step: Dict):
        Cls = cls.get_runner_cls(step)
        return cls.get_types(Cls, "input")

    @classmethod
    def update_parameters(cls, original_step_spec: Dict, **kwargs):
        """
        Return a shallow copy of the dictionary, updating with/overwriting the relevant values in kwargs

        In most circumstances, the base implementation should suffice.

        This classmethod can be overriden (see class Merge(DataOp))
        """
        param_names, Runner = cls.get_parameters(original_step_spec)
        filtered_kwargs = {
            key: value for key, value in kwargs.items() if key in param_names
        }
        return Runner.generate_specs(
            **{
                **original_step_spec,
                **filtered_kwargs,
            }
        )

    @classmethod
    def get_parameters(cls, ops: Dict, detail=True):
        """
        return a tuple containing:
        - parameter names of parameters that can be adjusted as list of str
        - class instance

        In most circumstances, the base class implementation should suffice.

        In most circumstances (such as the base usecase), the specification (ops provided as the first positional argument)
        is not required.

        This classmethod can be overriden (see class Merge(DataOp))
        """
        signatures = inspect.signature(cls.generate_specs)
        adjustable_param_names: List[str] = []
        for parameter in signatures.parameters.values():
            # see: https://docs.python.org/3/library/inspect.html#inspect.Parameter.kind
            # only allow KEYWORD_ONLY or POSITIONAL_OR_KEYWORD
            if parameter.kind not in (
                parameter.KEYWORD_ONLY,
                parameter.POSITIONAL_OR_KEYWORD,
            ):
                continue
            adjustable_param_names.append(parameter.name)

        return adjustable_param_names, cls


class Merge(DataOp):
    input: None
    Output: List[Any]
    type = "baseop/merge"
    desc = "Merge multiple srcs into a single src, output a list"

    def run(self, input, *, srcs: List[List[Dict]], **kwargs) -> List[Any]:
        from ..attributes.datarecipes.base import run_steps

        return [run_steps(src) for src in srcs]

    @classmethod
    def generate_specs(cls, *, srcs: List[List[Dict]], **kwargs):
        base = super().generate_specs(**kwargs)
        return {**base, "srcs": srcs}

    def desc(self, *, srcs: List[List[Dict]], detail=False, **kwargs):
        if not detail:
            return f"Merge {len(srcs)} into a single src, output a list"
        return_desc = (
            f"Merge the following {len(srcs)} srcs into a single src, output a list"
        )
        return_desc += "\n\n"
        for idx, src in enumerate(srcs, start=1):
            return_desc += f" source #{idx} "
            return_desc += "\n"
            src_desc = describe_operations(src, detail=detail)
            src_desc = "\n".join([f"    {line}" for line in src_desc.split("\n")])
            return_desc += src_desc
            return_desc += "\n"
        return_desc += "\n"
        return return_desc

    @classmethod
    def spec_from_datarecipes(cls, datarecipes: List["DataRecipe"]):
        srcs: List[Dict] = []
        for dv in datarecipes:
            srcs.append(dv.ops)
        return cls.generate_specs(srcs=srcs)

    @classmethod
    def get_parameters(cls, op: Dict, detail=False):
        return_params = []
        for src in op.get("srcs", []):
            for step in src:
                Cls = cls.get_runner_cls(step)
                params, _ = Cls.get_parameters(step)
                return_params.extend(params)
        return return_params, cls

    @classmethod
    def update_parameters(cls, original_step_spec, **kwargs):
        updated_srcs = []
        for src in original_step_spec.get("srcs", []):
            updated_src = []
            for step in src:
                Cls = cls.get_runner_cls(step)
                updated_src.append(Cls.update_parameters(step, **kwargs))
            updated_srcs.append(updated_src)
        return cls.generate_specs(srcs=updated_srcs)


class FromInstance(DataOp):
    """Utility Source Operation. This operation returns the instance provided, to be used by the next operation."""

    input: None
    output: Any
    type = "baseop/of"
    desc = "Output an {instance}"

    def run(self, _, instance, **kwargs):
        return instance

    @classmethod
    def generate_specs(cls, instance, **kwargs):
        base = super().generate_specs(**kwargs)
        return {**base, "instance": instance}
